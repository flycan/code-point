# 进程间通信

进程间通信常用方法

1. 管道
2. 消息队列
3. Unix Socket
4. 共享内存
5. 信号量(Semaphore)

## 管道

管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]

如果要实现父、子进程之间的双向数据传输，就必须使用两个管道.创建全双工管道的系统调用：socketpair。

管道只能用于有关联的两个进程（比如父、子进程）间的通信。
命名管道FIFO（First In First Out，先进先出）也能用于无关联进程之间的通信


所有的管道都遵循先进先出的原则

https://www.cnblogs.com/zhonglongbo/p/8591901.html

从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现为：
限制管道的大小。实际上，管道是一个固定大小的缓冲区。在Linux中，该缓冲区的大小为1页，即4K字节，使得它的大小不象文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，当这种情况发生时，随后对管道的write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供write()调用写。
读取进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认地被阻塞，等待某些数据被写入，这解决了read()调用返回文件结束的问题。
注意：从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据

### 管道的结构
 在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。

```
//创建管道
$pipePath = "/tmp/my.pipe";

posix_mkfifo( $pipePath, 0666 )

//创建进程,子进程写管道，父进程读管道
$pid = pcntl_fork();

if($pid < 0) {
    exit('fork failed');
}elseif( $pid == 0 ){
    //子进程写管道
    $file = fopen( $pipePath, 'w' );
    fwrite( $file, 'hello world' );
    sleep(1);
    exit();
}else{
    //父进程读管道
    $file = fopen( $pipePath, 'r' );
    //stream_set_blocking( $file, False );  //设置成读取非阻塞
    echo fread( $file, 20 ) . PHP_EOL;

    pcntl_wait($status);  //回收子进程
}
```

## 消息队列




## Socket

## 共享内存